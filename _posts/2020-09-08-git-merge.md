---
title: "Git Merge"
categories: 
  - Git
toc: true
---

### 2. 브랜치와 Merge의 기초

- 실제 갭ㄹ과정에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다.

1. **작업 중인 웹사이트가 있다.**
2. **새로운 이슈를 처리할 새 Branch를 하나 생성한다.**
3. **새로 만든 Branch에서 작업을 진행한다.**

- 이 때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다.

1. **새로운 잇를 처리하기 이전의 운영(Production) 브랜치로 이동한다.**
2. **Hotfix 브랜치를 새로 하나 생성한다.**
3. **수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge한다.**
4. **다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.**

**브랜치의 기초**

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%206.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%206.png)

- 위 그림은 iss53 작업을 하던 중에 문제를 처리하기 위해 hotfix 브랜치를 만든 모습이다.

```jsx
$ git checkout master
$ git merge hotfix
Fast-forward
```

- hotfix 테스트가 끝난 뒤 master 브랜치에 합쳐야 할 경우 master에 체크아웃한 뒤 merge 명령을 실행하면 된다.
- Merge할 브랜치가 가리키는 커밋이 현 브랜치 커밋의 Upstream 브랜치이기 때문에 master 브랜치 포인터는 merge 과정 없이 그저 최신 커밋으로 이동한다. 이런 Merge 방식을 **'Fast Forward'** 라고 부른다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%207.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%207.png)

- 이제 더 이상 hotfix 브랜치는 필요가 없으므로 제거한다.

```jsx
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
```

- 이제 다시 iss53 브랜치로 돌아가 하던 작업을 마저 하면 된다.

```jsx
$ git checkout iss53
```

**Merge의 기초**

- 53번 이슈를 다 구현하고 master 브랜치에 merge하는 과정을 살펴보자.

```jsx
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%208.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%208.png)

- 현재 브랜치가 가리키는 커밋이 Merge할 브랜치의 조상이 아니므로 Git은 **Fast-forward**로 Merge하지 않는다.
- 이 경우에 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 **3-way Merge**를 한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%209.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%209.png)

- 단순히 브랜치 포인터를 최신 커밋으로 올미는게 아니라 3-way Merge의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다.
- 이런 커밋은 부모가 여러 개고 **Merge 커밋**이라고 부른다.
- iss53 브랜치를 master에 Merge하고 나면 더는 iss53 브랜치가 필요없다. 때문에 삭제해도 상관없다.

### 3. 브랜치 관리

- 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자.

```jsx
$ git brach
  iss53
* master
  testing
```

- * 기호가 붙어 있는 master 브랜치는 현재 Checkout해서 작업하는 브랜치를 나타낸다.

```jsx
$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
```

- -v 옵션은 마지막 커밋의 메시지도 함께 보여준다.

```jsx
$ git branch --merged
  iss53
* master
```

- —merged 옵션은 현재 브랜치 기준으로 merge 된 브랜치들을 보여준다.
- * 기호가 붙어있지 않은 브랜치는 삭제해도 되는 브랜치이다.

```jsx
$ git branch --no-merged
  testing
```

- 반대로 현재 checkout한 브랜치에 merge하지 않은 브랜치를 살펴보려면 위 옵션을 사용하면 된다.

### 4. 리모트 브랜치

- 리모트 Refs는 리모트 저장소에 있는 포인터인 레퍼런스다. 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다.
- 리모트 Refs가 있지만 보통은 리모트 트래킹 브랜치를 사용한다.

**리모트 트래킹 브랜치**

- 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 브랜치다.
- 리모트 서버에 연결할 대마다 리모트 브랜치에 따라서 자동으로 움직일 뿐이다.
- 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다.
- 리모트 브랜치의 이름은 (remote)/(branch) 형식으로 되어 있다.
- 예를 들어, 리모트 저장소 origin의 master 브랜치를 보고 싶다면 origin/master라는 이름으로 브랜치를 확인하면 된다.

- 예를 들어 git.ourcompany.com이라는 Git서버가 있고 이 서버의 저장소를 하나 Clone하면 Git은 자동으로 origin이라는 이름을 붙인다.
- origin으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master라고 부르고 멋대로 조종할 수 없다.
- 그리고 Git은 로컬의 master 브랜치가 origin/master를 가리키게 한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2010.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2010.png)

- 로컬 저장소에서 어떤 작업을 하고 있는데 동시에 다른 팀원이 [git.ourcompany.com](http://git.ourcompany.com) 서버에 Push하고 master 브랜치를 업데이트한다. 그러면 이제 팀원간의 히스토리는 서로 달라진다.
- 서버 저장소로부터 어떤 데이터도 주고받지 않아서 origin/master 포인터는 그대로다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2011.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2011.png)

- 리모트 서버로부터 저장소 정보를 동기화하려면 git fetch origin 명령을 사용한다.
- 명령을 실행하면 우선 'origin' 서버의 주소 정보(이 예에서는 git.ourcompany.com)를 찾아서, 현재 로컬의 저장소가 갖고있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서 origin/master 포인터의 최신 커밋으로 이동시킨다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2012.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2012.png)

**Push하기**

- 로컬의 브랜치를 서버로 전송하기 위해 push 명령어를 사용한다.

```jsx
$ git push origin serverfix
```

- serverfix 브랜치를 origin 리모트에 push한다.

Pull하기

- pull 명령은 사실상 fetch한 후에 merge를 자동으로 해준것이라 할수 있다.

```jsx
$ git pull 
```

### 5. Reabase하기

- Git에서 브랜치에서 다른 브랜치로 합치는 방법은 두 가지다.
- 하나는 Merge이고 다른 하나는 Rebase이다.

**Rebase의 기초**

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2013.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2013.png)

- 위 브랜치를 합치는 방법은 merge 명령을 사용하는 것이다. merge 명령을 사용하면 3-way Merge로 새로운 커밋을 만들어낸다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2014.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2014.png)

- rebase 명령은 일단 두 브랜치가 나뉘기 전인 공통 커밋으로 이동하고 나서 그 커밋부터 지금 Checkout한 브랜치가 가리키는 커밋까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다. Rebase할 브랜치가 합칠 브랜치가 가리키는 커밋을 가리키게 하고 아가 저장해 놓았던 변경사항을 차례대로 적용한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2015.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2015.png)

- 그러고 나서 master 브랜치를 Fast-forward한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2016.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2016.png)

- C4' 기준으로 보면 사실상 merge 명령과 결과적으로 다른게 없다. 하지만 rebase가 좀 더 깨끗한 히스토리를 만든다.
- Rebase한 브랜치의 Log를 살펴보면 히스토리가 선형이다.

**Rebase 활용**

- Rebase는 단순히 브랜치를 합치는 것만 아니라 다른 용도로도 사용할 수 있다. server 브랜치를 만들어서 서버 기능을 추가하고 그 브랜치에서 다시 client 브랜치를 만들어 클라이언트 기능을 추가한다. 마지막으로 server 브랜치로 돌아가서 몇 가지 기능을 더 추가한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2017.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2017.png)

- 이 때 테스트가 덜 된 server 브랜치는 그대로 두고 client 브랜치만 master로 합치려는 상황을 생각해보자. server와는 아무 관련이 없는 client 커밋은 C8, C9 이다. 이 두 커밋을 master 브랜치에 적용하기 위해서는 —onto 옵션을 사용하여 아래와 같은 명령을 실행한다.

```jsx
$ git rebase --onto master server client
```

- 이 명령은 master 브랜치로부터 server 브랜치와 client 브랜치의 공통 조상까지의 커밋을 client 브랜치에서 없애고 싶을 때 사용한다. client 브랜치에서만 변경된 패치를 만들어 master 브랜치에서 client 브랜치를 기반으로 새로 만들어 적용한다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2018.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2018.png)

- 이제 master 브랜치로 돌아가서 Fast-forward 시킬 수 있다.

```jsx
$ git checkout master
$ git merge client
```

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2019.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2019.png)

- server 브랜치의 일이 다 끝나면 git rebase <basebranch> <topicbranh> 라는 명령으로 Checkout 하지 않고 바로 server 브랜치를 master 브랜치로 Rebase 할 수 있다.

```jsx
$ git rebase master server
```

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2020.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2020.png)

- 그리고 나서 master 브랜치를 fast-forward 시킨다.

```jsx
$ git checkout master
$ git merge server
$ git branch -d client
$ git branch -d server
```

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2021.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2021.png)

**Rebase의 위험성**

- Rebase가 장점이 많은 기능이지만 단점이 없는 것은 아니니 조심해야 한다. 그 주의사항은 아래 한 문장으로 표현할 수 있다.
- **이미 공개 저장소에 Push 한 커밋을 Rebase 하지 마라**
- Rebase는 기존 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 다른 커밋을 새로 만든다.
- 새 커밋을 서버에 Push하고 동료 중 누군가가 그 커밋을 Pull 해서 작업을 한다고 하자.
- 그런데 그 커밋을 git rebase 로 바꿔서 Push 해버리면 동료가 다시 Push 했을 때 동료는 다시 Merge 해야한다. 그리고 동료가 다시 Merge 한 내용을 Pull 하면 내 코드는 정말 엉망이 된다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2022.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2022.png)

- 이제 팀원 중 누군가 커밋, Merge 하고 나서 서버에 Push 한다. 이 리모트 브랜치를 Fetch, Merge 하면 히스토리는 아래와 같이 된다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2023.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2023.png)

- 그런데 Push 했던 팀원은 Merge 한 일을 되돌리고 다시 Rebase 한다. 서버의 히스토리를 새로 덮어씌우려면 git push —force 명령을 사용해야한다. 이후에 저장소에서 Fetch 하고 나면 아래 그림과 같은 상태가 된다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2024.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2024.png)

- 한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase 한 커밋을 다시 Push함
- git pull 로 서버의 내용을 가져와서 Merge 하면 같은 내용의 수정사항을 포함한 Merge 커밋이 아래와 같이 만들어진다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2025.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2025.png)

- git log 로 히스토리를 확인해보면 저자, 날짜 메시지가 같은 커밋이 두 개 있다. (C4,C4') 이렇게 되면 혼란스럽다. 게다가 이 히스토리를 서버에 Push 하면 같은 커밋이 두 개 있기 때문에 다른 사람들도 혼란스러워 한다. 'C4', 'C6' 는 포함되지 말았어야 할 커밋이다. 애초에 서버로 데이터를 보내기 전에 Rebase로 커밋을 정리했어야 했다.

**Rebase 한 것을 다시 Rebase 하기**

- 만약 이런 상황에 빠질 때 유용한 Git 기능이 하나 있다. 어떤 팀원이 강제로 내가 한일을 덮어썼다고 하자. 그러면 내가 했던 일이 무엇이고 덮어쓴 내용이 무엇인지 알아내야한다.
- 커밋 SHA 체크섬 외에도 Git은 커밋에 Patch 할 내용으로 SHA-1 체크섬을 한번 더 구한다. 이 값은 patch-id 라고 한다.
- 예를 들어 앞서 살펴본 예제를 보면 **한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase 한 커밋을 다시 Push 함** 상황에서 Merge 하는 대신 git rebase teamone/master 명령을 실행하면 Git은 아래와 같은 작업을 한다.
  1. 현재 브랜치에만 포함된 커밋을 찾는다. (C2, C3, C4, C6, C7)
  2. Merge 커밋을 가려낸다. (C2, C3, C4)
  3. 이 중 덮어쓰지 않은 커밋들만 골라낸다. (C2, C3, C4는 C4'와 동일한 Patch다.)
  4. 남은 커밋들만 다시 teamone/master 바탕으로 커밋을 쌓는다.
- 결과를 확인해 보면 같은 Merge를 다시 한다 같은 결과 대신 제대로 정리된 강제로 덮어쓴 브랜치에 Rebase하기 같은 결과를 얻을 수 있다.

![Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2026.png](Git%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8E%E1%85%B5%201f85e910c6154b5689be747a4c50d7ea/Untitled%2026.png)